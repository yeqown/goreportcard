package linter

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"

	"github.com/gojp/goreportcard/internal/types"
	"github.com/pkg/errors"
	"github.com/yeqown/log"
)

var (
	skipDirs       = []string{"Godeps", "vendor", "third_party", "testdata", "examples"}
	skipSuffixes   = []string{".pb.go", ".pb.gw.go", ".generated.go", "bindata.go", "_string.go"}
	skipFirstLines = []string{"code generated", "generated", "autogenerated", "@generated", "code autogenerated", "auto-generated"}
)

// GoFiles returns a slice of Go filenames
// in a given directory.
func visitGoFiles(dir string) (filenames []string, err error) {
	visitFn := func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			// can't walk here, but continue walking elsewhere
			log.Warnf("visitGoFiles got err=%v", err)
			return nil
		}

		if fi.IsDir() {
			return nil // not a file, ignore.
		}

		// if file in skip folder
		for _, skip := range skipDirs {
			if strings.Contains(path, fmt.Sprintf("/%s/", skip)) {
				return nil
			}
		}

		filename := fi.Name()
		for _, skip := range skipSuffixes {
			if strings.HasSuffix(filename, skip) {
				return nil
			}
		}

		// not .go file or generated go files, ignore
		if filepath.Ext(filename) != ".go" || isGenerated(path) {
			return nil
		}

		filenames = append(filenames, path)
		return nil
	}

	err = filepath.Walk(dir, visitFn)
	return filenames, err
}

// lineCount returns the number of lines in a given file
func lineCount(filename string) (int, error) {
	out, err := exec.Command("wc", "-l", filename).Output()
	if err != nil {
		return 0, err
	}
	// `wc -l` output is like: 999 filename.go
	count, err := strconv.Atoi(strings.Split(strings.TrimSpace(string(out)), " ")[0])
	if err != nil {
		return 0, errors.Errorf("could not count lines: %v", err)
	}

	return count, nil
}

// determine whether the Go file was auto-generated
// FIXME: fp is not right path to file
func isGenerated(fp string) bool {
	file, err := os.Open(fp)
	if err != nil {
		fp, _ = filepath.Abs(fp)
		log.Errorf("isGenerated failed to open file err=%v, fp=%s", err, fp)
		return false
	}
	defer file.Close()

	// read first line of file and determine if it might
	// be auto-generated
	scanner := bufio.NewScanner(file)
	scanner.Scan()
	line := strings.ToLower(scanner.Text())
	commentStyles := []string{"// ", "//", "/* ", "/*"}
	for _, skip := range skipFirstLines {
		for i := range commentStyles {
			if strings.HasPrefix(line, commentStyles[i]) && strings.HasPrefix(line[len(commentStyles[i]):], skip) {
				return true
			}
		}
	}
	return false
}

// assembleRemoteFileURI with repoDir, branchName and relativePathToFile
func assembleRemoteFileURI(dir, relativePath string) (URI string) {
	root := strings.TrimPrefix(dir, types.GetConfig().RepoRoot)
	branchName := "master"
	// default means, https://HOST/blob/BRANCH_NAME/PATH_TO_FILE
	uriFmt := "https://%s/blob/%s/%s"
	for _, rule := range types.GetConfig().URIFormatRules {
		if strings.HasPrefix(root, rule.Prefix) {
			uriFmt = rule.URIFormat
		}
	}

	// log.Debugf("assembleRemoteFileURI got uriFmt=%s, root=%s, branchName=%s, relativePath=%s",
	// 	uriFmt, root, branchName, relativePath)
	return fmt.Sprintf(uriFmt, root, branchName, relativePath)
}

// issue as following format:
//
// {
// 	"FromLinter": "deadcode",
// 	"Text": "`findCaller` is unused",
// 	"SourceLines": [
// 		"func findCaller(skip int) (file, function string, line int) {"
// 	],
// 	"Replacement": null,
// 	"Pos": {
// 		"Filename": "caller.go",
// 		"Offset": 52,
// 		"Line": 8,
// 		"Column": 6
// 	},
// 	"ExpectNoLint": false,
// 	"ExpectedNoLintLinter": ""
// }
//
type issue struct {
	FromLinter  string   `json:"FromLinter"`
	Text        string   `json:"Text"`
	SourceLines []string `json:"SourceLines"`
	Pos         struct {
		Filename string
		Offset   int
		Line     int
		Column   int
	} `json:"Pos"`
}

type golangciLintOutput struct {
	Issues []issue
}

// parseGolangciLintInJSON parse json output into types.FileSummary
func parseGolangciLintInJSON(data []byte, dir string) ([]types.FileSummary, error) {
	output := new(golangciLintOutput)
	if err := json.Unmarshal(data, output); err != nil {
		return nil, errors.Wrap(err, "parseGolangciLintInJSON.jsonUnmarshal")
	}

	// log.Debugf("parseGolangciLintInJSON got result=%s, output=%+v", data, output)
	m := make(map[string]*types.FileSummary, 64)
	for _, issue := range output.Issues {
		if !strings.HasSuffix(issue.Pos.Filename, ".go") {
			// true: if not valid filename
			continue
		}

		for _, skip := range skipSuffixes {
			if strings.HasSuffix(issue.Pos.Filename, skip) {
				// continue outer
				break
			}
		}
		if isGenerated(filepath.Join(dir, issue.Pos.Filename)) {
			continue
		}

		var (
			summary *types.FileSummary
			ok      bool
		)
		if summary, ok = m[issue.Pos.Filename]; !ok {
			// summary of `filename` with error not exists, then initialize the one
			summary = &types.FileSummary{
				Filename: issue.Pos.Filename,
				FileURL:  assembleRemoteFileURI(dir, issue.Pos.Filename),
			}
		}

		// TODO: add more message to Error and show them out
		summary.AddError(types.Error{
			LineNumber:  issue.Pos.Line,
			ErrorString: issue.Text,
		})
		m[summary.Filename] = summary
	}

	summaries := make([]types.FileSummary, len(m))
	for _, v := range m {
		summaries = append(summaries, *v)
	}

	return summaries, nil
}

// cmdHelper runs a given go command (for example gofmt, go tool vet)
// on a directory
func cmdHelper(dir string, filenames, command []string) (float64, []types.FileSummary, error) {
	params := command[1:]
	params = append(params, "./...")

	cmd := exec.Command(command[0], params...)
	cmd.Dir, _ = filepath.Abs(dir)

	log.Debugf("cmdHelper got command=[%s] in Dir=[%s]", cmd.String(), cmd.Dir)

	// create an pipe to recv stdout message
	r, err := cmd.StdoutPipe()
	if err != nil {
		return 0, nil, errors.Wrap(err, "cmdHelper.cmd.StdoutPipe")
	}
	defer r.Close()
	cmd.Stderr = cmd.Stdout

	if err = cmd.Start(); err != nil {
		return 0, nil, errors.Wrap(err, "cmdHelper.cmd.Start")
	}

	// the same file can appear multiple times out of order
	// in the output, so we can't go line by line, have to store
	// a map of filename to FileSummary
	summaries, err := scanAndWait(r, cmd, dir)
	if err != nil {
		log.Warnf("cmdHelper failed to scanAndWait, err=%v", err)
		return 0, nil, err
	}

	log.Debugf("one cmd=%s finished", cmd.String())
	// TRUE: sif only 1 file, so calc socre = sum(error line) / sum(line)
	if len(filenames) == 1 {
		lc, err := lineCount(filenames[0])
		if err != nil {
			return 0, summaries, err
		}

		errCnt := 0
		if len(summaries) != 0 {
			errCnt = len(summaries[0].Errors)
		}

		return float64(lc-errCnt) / float64(lc), summaries, nil
	}

	// ELSE: sum(no error file) / sum(file)
	return float64(len(filenames)-len(summaries)) / float64(len(filenames)), summaries, nil
}

// scanAndWait scan stdout and call `cmd.Wait`,
// to get golangci-lint result to parse or return error
//
// 1. get all stdout
// 2. judge cmd status, error to return
// 3. else to parse error output
func scanAndWait(r io.ReadCloser, cmd *exec.Cmd, dir string) ([]types.FileSummary, error) {
	scanner := bufio.NewScanner(r)
	buf := bytes.NewBuffer(nil)

	// 1. collect cache
	for scanner.Scan() {
		buf.Write(scanner.Bytes())
	}
	if err := scanner.Err(); err != nil {
		return nil, errors.Wrap(err, "cmdHelper.scanner.Err")
	}
	// log.Debugf("scanAndWait got linesBuf.length = %d", len(linesBuf))

	// 2. wait and judge command exit status
	err := cmd.Wait()
	if exitErr, ok := err.(*exec.ExitError); ok {
		// The program has exited with an exit code != 0
		if status, ok := exitErr.Sys().(syscall.WaitStatus); ok {
			// some commands exit 1 when files fail to pass (for example go vet)
			if status.ExitStatus() == 1 {
				goto parse
			}
		}

		// make stdout message as error message
		return nil, errors.New(buf.String())
	}

parse:
	// 3. command runs and quit normal, parse stdout errors
	summaries, err := parseGolangciLintInJSON(buf.Bytes(), dir)
	if err != nil {
		return nil, errors.Wrap(err, "cmdHelper.parseStdoutLines")
	}

	// FIXED: format invalid to return
	return summaries, nil
}
